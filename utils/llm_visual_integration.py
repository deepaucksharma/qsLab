"""
LLM Visual Integration for Neural Learn Platform
Integrates LLM-generated visual specifications with the existing learning platform
"""

import json
import asyncio
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from datetime import datetime

@dataclass
class VisualSpecification:
    """Represents a visual specification generated by an LLM"""
    visual_type: str
    visual_id: str
    title: str
    components: List[Dict[str, Any]]
    animations: Optional[List[Dict[str, Any]]] = None
    interactions: Optional[List[Dict[str, Any]]] = None
    complexity: str = "intermediate"
    
class LLMVisualIntegration:
    """
    Integrates LLM visual generation with the Neural Learn platform
    """
    
    def __init__(self, app=None):
        self.app = app
        self.visual_cache = {}
        self.segment_type_mappings = self._initialize_mappings()
        
        if app:
            self.init_app(app)
    
    def init_app(self, app):
        """Initialize with Flask app"""
        self.app = app
        
        # Add visual generation endpoints
        app.add_url_rule('/api/generate-visual', 
                        'generate_visual', 
                        self.generate_visual_endpoint, 
                        methods=['POST'])
        app.add_url_rule('/api/visual-spec/<visual_id>', 
                        'get_visual_spec', 
                        self.get_visual_spec_endpoint, 
                        methods=['GET'])
    
    def _initialize_mappings(self):
        """Map segment types to appropriate visual types"""
        return {
            # Opening and introduction segments
            'course_opening': 'animated-diagram',
            'instructor_introduction': 'animated-diagram',
            'episode_opening': 'animated-diagram',
            
            # Architecture and flow segments
            'technical_introduction': 'animated-diagram',
            'architecture_design': 'animated-diagram',
            'scalability_concept': 'animated-diagram',
            'concept_explanation': 'animated-diagram',
            'concept_introduction': 'animated-diagram',
            
            # Metric and data segments
            'metric_deep_dive': 'metric-dashboard',
            'new_metric_deep_dive': 'metric-dashboard',
            'metrics_overview': 'metric-dashboard',
            'metric_taxonomy': 'metric-dashboard',
            
            # Historical and timeline segments
            'historical_context': 'interactive-timeline',
            'origin_story': 'interactive-timeline',
            
            # Code segments
            'code_walkthrough': 'code-playground',
            'practical_example': 'code-playground',
            'practical_configuration': 'code-playground',
            
            # Comparison segments
            'paradigm_shift': 'comparison-view',
            'technology_comparison': 'comparison-view',
            'decision_framework': 'comparison-view',
            
            # Interactive segments
            'simulation': 'simulation',
            'scenario_selection': 'simulation',
            'field_mapping_exercise': 'simulation',
            
            # Problem and recap segments
            'problem_recap': 'animated-diagram',
            
            # Feature segments
            'feature_introduction': 'animated-diagram',
            'new_feature_highlight': 'animated-diagram',
            'new_feature_discovery': 'animated-diagram',
            
            # UI and schema segments
            'ui_walkthrough': 'simulation',
            'schema_introduction': 'code-playground',
            'advanced_customization': 'code-playground'
        }
    
    async def generate_visual_for_segment(self, segment_data: Dict) -> Dict:
        """
        Generate visual specification for a learning segment
        """
        # Determine visual type based on segment type
        visual_type = self.segment_type_mappings.get(
            segment_data.get('segmentType'), 
            'animated-diagram'
        )
        
        # Generate specification based on visual type
        if visual_type == 'animated-diagram':
            return await self._generate_animated_diagram(segment_data)
        elif visual_type == 'metric-dashboard':
            return await self._generate_metric_dashboard(segment_data)
        elif visual_type == 'interactive-timeline':
            return await self._generate_timeline(segment_data)
        elif visual_type == 'code-playground':
            return await self._generate_code_playground(segment_data)
        elif visual_type == 'comparison-view':
            return await self._generate_comparison(segment_data)
        elif visual_type == 'simulation':
            return await self._generate_simulation(segment_data)
        else:
            return await self._generate_default_visual(segment_data)
    
    async def _generate_animated_diagram(self, segment_data: Dict) -> Dict:
        """Generate animated diagram specification"""
        # Check if we have a pre-crafted specification
        segment_id = segment_data.get('segmentId', '')
        visual_spec_path = f'visual_specs/{segment_id}.json'
        
        # Try to load pre-crafted specification
        import os
        if os.path.exists(visual_spec_path):
            with open(visual_spec_path, 'r') as f:
                import json
                return json.load(f)
        
        # Parse keywords and content to determine components
        keywords = segment_data.get('keywords', [])
        text_content = segment_data.get('textContent', '')
        segment_type = segment_data.get('segmentType', '')
        
        # Special handling for course opening
        if segment_type == 'course_opening':
            return await self._generate_welcome_visual(segment_data)
        
        # Special handling for instructor introduction
        if segment_type == 'instructor_introduction':
            return await self._generate_instructor_intro_visual(segment_data)
        
        # Example: Kafka architecture diagram
        if any(k.lower() in ['kafka', 'partition', 'topic'] for k in keywords):
            return {
                "visualType": "animated-diagram",
                "visualId": f"diagram-{segment_data['segmentId']}",
                "title": segment_data.get('title', 'Architecture Diagram'),
                "components": [
                    {
                        "type": "topic",
                        "id": "main-topic",
                        "label": "Messages",
                        "position": {"x": 100, "y": 200},
                        "properties": {
                            "partitionCount": 3,
                            "replicationFactor": 2
                        }
                    },
                    {
                        "type": "producer",
                        "id": "producer-1",
                        "label": "Producer",
                        "position": {"x": 50, "y": 200},
                        "connections": [{
                            "to": "main-topic",
                            "animationType": "message-flow",
                            "rate": 100
                        }]
                    }
                ],
                "animations": [
                    {
                        "trigger": "onLoad",
                        "sequence": [
                            {
                                "action": "showComponent",
                                "target": "producer-1",
                                "duration": 500
                            },
                            {
                                "action": "animateMessages",
                                "from": "producer-1",
                                "to": "main-topic",
                                "count": 5,
                                "duration": 2000
                            }
                        ]
                    }
                ],
                "interactions": [
                    {
                        "type": "hover",
                        "target": "main-topic",
                        "action": "showDetails",
                        "content": {
                            "metrics": ["throughput", "lag", "partitionDistribution"]
                        }
                    }
                ]
            }
        
        # Default animated diagram
        return self._create_default_diagram(segment_data)
    
    async def _generate_welcome_visual(self, segment_data: Dict) -> Dict:
        """Generate specialized welcome visual for course opening"""
        return {
            "visualType": "animated-diagram",
            "visualId": f"welcome-{segment_data['segmentId']}",
            "title": "Welcome to Your Learning Journey",
            "canvas": {
                "width": 1200,
                "height": 600,
                "background": {
                    "type": "gradient",
                    "gradient": {
                        "type": "linear",
                        "angle": 180,
                        "stops": [
                            {"offset": 0, "color": "#f8f9fa"},
                            {"offset": 100, "color": "#e8f0fe"}
                        ]
                    }
                }
            },
            "components": [
                {
                    "type": "text",
                    "id": "welcome-text",
                    "content": segment_data.get('title', 'Welcome'),
                    "position": {"x": 600, "y": 150},
                    "style": {
                        "fontSize": 42,
                        "fontWeight": 300,
                        "color": "#202124",
                        "textAlign": "center"
                    }
                },
                {
                    "type": "journey-indicator",
                    "id": "course-path",
                    "position": {"x": 600, "y": 300},
                    "steps": 3,
                    "currentStep": 0,
                    "labels": ["Start", "Learn", "Master"]
                }
            ],
            "animations": [
                {
                    "trigger": "onLoad",
                    "sequence": [
                        {
                            "action": "fadeIn",
                            "target": "welcome-text",
                            "duration": 1500,
                            "delay": 500
                        },
                        {
                            "action": "slideInUp",
                            "target": "course-path",
                            "duration": 1000,
                            "delay": 1500
                        }
                    ]
                }
            ]
        }
    
    async def _generate_instructor_intro_visual(self, segment_data: Dict) -> Dict:
        """Generate instructor introduction visual"""
        return {
            "visualType": "animated-diagram",
            "visualId": f"instructor-{segment_data['segmentId']}",
            "title": "Your Guide Through This Journey",
            "components": [
                {
                    "type": "journey-map",
                    "id": "course-pillars",
                    "position": {"x": 600, "y": 300},
                    "nodes": [
                        {
                            "id": "fundamentals",
                            "label": "Fundamentals",
                            "icon": "foundation",
                            "position": {"x": -200, "y": 0}
                        },
                        {
                            "id": "monitoring",
                            "label": "Monitoring",
                            "icon": "dashboard",
                            "position": {"x": 0, "y": 0}
                        },
                        {
                            "id": "share-groups",
                            "label": "Share Groups",
                            "icon": "network",
                            "position": {"x": 200, "y": 0}
                        }
                    ]
                }
            ],
            "animations": [
                {
                    "trigger": "onLoad",
                    "sequence": [
                        {
                            "action": "springIn",
                            "target": "course-pillars",
                            "duration": 2000,
                            "stagger": 300
                        }
                    ]
                }
            ]
        }
    
    async def _generate_metric_dashboard(self, segment_data: Dict) -> Dict:
        """Generate metric dashboard specification"""
        keywords = segment_data.get('keywords', [])
        
        # Determine which metrics to show
        widgets = []
        
        if 'unacknowledged_age_ms' in str(keywords):
            widgets.append({
                "type": "time-series",
                "metric": "unacknowledged_age_ms",
                "aggregation": "p99",
                "timeRange": "5m",
                "thresholds": {
                    "warning": 30000,
                    "critical": 60000
                }
            })
        
        if 'redelivery_count' in str(keywords):
            widgets.append({
                "type": "gauge",
                "metric": "redelivery_count",
                "showTrend": True,
                "sparkline": True
            })
        
        # Add default metrics if none specified
        if not widgets:
            widgets = [
                {
                    "type": "time-series",
                    "metric": "message_throughput",
                    "aggregation": "avg",
                    "timeRange": "10m"
                },
                {
                    "type": "stat-card",
                    "metric": "queue_depth",
                    "showTrend": True
                }
            ]
        
        return {
            "visualType": "metric-dashboard",
            "visualId": f"dashboard-{segment_data['segmentId']}",
            "title": segment_data.get('title', 'Metrics Dashboard'),
            "layout": "grid",
            "refreshRate": 1000,
            "widgets": widgets,
            "dataSource": "simulated",
            "simulationProfile": "normal-with-spikes"
        }
    
    async def _generate_timeline(self, segment_data: Dict) -> Dict:
        """Generate interactive timeline specification"""
        # Check for pre-crafted specification
        segment_id = segment_data.get('segmentId', '')
        visual_spec_path = f'visual_specs/{segment_id}.json'
        
        import os
        if os.path.exists(visual_spec_path):
            with open(visual_spec_path, 'r') as f:
                import json
                return json.load(f)
        
        # Extract dates and events from content
        text_content = segment_data.get('textContent', '')
        keywords = segment_data.get('keywords', [])
        
        # Special handling for LinkedIn crisis
        if any(k in ['LinkedIn', '2010', 'Data Pipeline'] for k in keywords):
            return await self._generate_linkedin_crisis_timeline(segment_data)
        
        events = []
        
        # Look for year patterns
        if '2010' in text_content:
            events.append({
                "date": "2010-01-01",
                "title": "LinkedIn Data Crisis",
                "description": "Point-to-point integrations become unmanageable",
                "type": "problem"
            })
        
        if 'kafka' in text_content.lower():
            events.append({
                "date": "2011-01-01",
                "title": "Apache Kafka Created",
                "description": "Distributed streaming platform is born",
                "type": "solution"
            })
        
        return {
            "visualType": "interactive-timeline",
            "visualId": f"timeline-{segment_data['segmentId']}",
            "title": segment_data.get('title', 'Historical Timeline'),
            "events": events,
            "options": {
                "zoom": True,
                "clustering": True,
                "animation": True
            }
        }
    
    async def _generate_linkedin_crisis_timeline(self, segment_data: Dict) -> Dict:
        """Generate specialized LinkedIn crisis timeline"""
        return {
            "visualType": "interactive-timeline",
            "visualId": f"crisis-timeline-{segment_data['segmentId']}",
            "title": "The Data Integration Crisis",
            "theme": "crisis",
            "timeline": {
                "start": "2008",
                "end": "2012",
                "focusYear": "2010"
            },
            "networkComplexity": {
                "2008": {"nodes": 10, "connections": 15},
                "2009": {"nodes": 25, "connections": 60},
                "2010": {"nodes": 40, "connections": 142},
                "2011": {"nodes": 45, "connections": 180}
            },
            "metrics": {
                "pipelines": 142,
                "maintenanceHours": 320,
                "dataLatency": "24 hours"
            }
        }
    
    async def _generate_code_playground(self, segment_data: Dict) -> Dict:
        """Generate code playground specification"""
        # Extract code from segment or generate example
        code_example = self._extract_code_from_segment(segment_data)
        
        return {
            "visualType": "code-playground",
            "visualId": f"playground-{segment_data['segmentId']}",
            "title": segment_data.get('title', 'Code Example'),
            "language": "java",  # Default, could be detected
            "executionMode": "step-through",
            "code": code_example,
            "visualizations": [
                {
                    "type": "execution-flow",
                    "highlightVariables": ["consumer", "records"],
                    "showMemoryState": True
                }
            ],
            "interactiveElements": []
        }
    
    async def _generate_comparison(self, segment_data: Dict) -> Dict:
        """Generate comparison view specification"""
        # Determine what to compare based on keywords
        keywords = segment_data.get('keywords', [])
        
        if 'consumer' in str(keywords).lower() and 'share' in str(keywords).lower():
            return {
                "visualType": "comparison-view",
                "visualId": f"comparison-{segment_data['segmentId']}",
                "title": "Consumer Groups vs Share Groups",
                "layout": "split-screen",
                "subjects": [
                    {
                        "title": "Consumer Groups",
                        "visualization": {
                            "type": "partition-assignment",
                            "showLimitations": True
                        },
                        "keyPoints": [
                            "One consumer per partition max",
                            "Ordered processing guaranteed",
                            "Simple offset management"
                        ]
                    },
                    {
                        "title": "Share Groups",
                        "visualization": {
                            "type": "cooperative-consumption",
                            "showAdvantages": True
                        },
                        "keyPoints": [
                            "Multiple consumers per partition",
                            "Queue-like semantics",
                            "Individual message acknowledgment"
                        ]
                    }
                ],
                "transitionEffect": "morph",
                "interactiveToggle": True
            }
        
        return self._create_default_comparison(segment_data)
    
    async def _generate_simulation(self, segment_data: Dict) -> Dict:
        """Generate simulation specification"""
        return {
            "visualType": "simulation",
            "visualId": f"sim-{segment_data['segmentId']}",
            "title": segment_data.get('title', 'Interactive Simulation'),
            "simulationType": "queue-processing",
            "controls": [
                {
                    "type": "slider",
                    "parameter": "consumers",
                    "min": 1,
                    "max": 10,
                    "default": 1
                },
                {
                    "type": "slider",
                    "parameter": "productionRate",
                    "min": 50,
                    "max": 500,
                    "default": 100
                }
            ],
            "metrics": ["queueDepth", "processingLag", "throughput"],
            "scoring": True
        }
    
    def _extract_code_from_segment(self, segment_data: Dict) -> str:
        """Extract or generate code example from segment"""
        # Check if segment has code example
        if 'codeExample' in segment_data:
            return segment_data['codeExample'].get('snippet', '')
        
        # Generate default code based on keywords
        keywords = segment_data.get('keywords', [])
        
        if 'share group' in str(keywords).lower():
            return """// Share Group Consumer Example
KafkaShareGroupConsumer consumer = new KafkaShareGroupConsumer(props);
consumer.subscribe("orders", "payment-processors");

while (true) {
    Records records = consumer.poll(Duration.ofMillis(100));
    processRecords(records);
    consumer.acknowledge(records);
}"""
        
        return "// Code example will be generated here"
    
    def _create_default_diagram(self, segment_data: Dict) -> Dict:
        """Create a default diagram specification"""
        return {
            "visualType": "animated-diagram",
            "visualId": f"diagram-{segment_data['segmentId']}",
            "title": segment_data.get('title', 'Concept Diagram'),
            "components": [
                {
                    "type": "concept-box",
                    "id": "main-concept",
                    "label": segment_data.get('title', 'Main Concept'),
                    "position": {"x": 200, "y": 200}
                }
            ],
            "animations": [
                {
                    "trigger": "onLoad",
                    "sequence": [
                        {
                            "action": "fadeIn",
                            "target": "main-concept",
                            "duration": 1000
                        }
                    ]
                }
            ]
        }
    
    def _create_default_comparison(self, segment_data: Dict) -> Dict:
        """Create a default comparison specification"""
        return {
            "visualType": "comparison-view",
            "visualId": f"comparison-{segment_data['segmentId']}",
            "title": segment_data.get('title', 'Comparison'),
            "layout": "side-by-side",
            "subjects": [
                {
                    "title": "Option A",
                    "keyPoints": ["Point 1", "Point 2"]
                },
                {
                    "title": "Option B",
                    "keyPoints": ["Point 1", "Point 2"]
                }
            ]
        }
    
    async def _generate_default_visual(self, segment_data: Dict) -> Dict:
        """Generate a default visual specification"""
        return {
            "visualType": "enhanced-text",
            "visualId": f"text-{segment_data['segmentId']}",
            "title": segment_data.get('title', 'Content'),
            "content": segment_data.get('textContent', ''),
            "styling": {
                "theme": "modern",
                "animation": "fade-in"
            }
        }
    
    # Flask endpoints
    def generate_visual_endpoint(self):
        """API endpoint to generate visual specification"""
        try:
            data = request.get_json()
            segment_data = data.get('segment')
            
            if not segment_data:
                return jsonify({'error': 'No segment data provided'}), 400
            
            # Generate visual specification
            visual_spec = asyncio.run(
                self.generate_visual_for_segment(segment_data)
            )
            
            # Cache the specification
            visual_id = visual_spec['visualId']
            self.visual_cache[visual_id] = visual_spec
            
            return jsonify({
                'success': True,
                'visualId': visual_id,
                'specification': visual_spec
            })
            
        except Exception as e:
            return jsonify({'error': str(e)}), 500
    
    def get_visual_spec_endpoint(self, visual_id):
        """Get cached visual specification"""
        if visual_id in self.visual_cache:
            return jsonify(self.visual_cache[visual_id])
        else:
            return jsonify({'error': 'Visual not found'}), 404


# Integration with existing segment rendering
def enhance_segment_with_visual(segment_data: Dict, visual_integration: LLMVisualIntegration) -> Dict:
    """
    Enhance a segment with LLM-generated visual specification
    """
    # Generate visual specification
    visual_spec = asyncio.run(
        visual_integration.generate_visual_for_segment(segment_data)
    )
    
    # Add to segment data
    segment_data['generatedVisual'] = visual_spec
    
    return segment_data


# JavaScript integration code
JS_INTEGRATION = """
// Integration with existing segment renderer
class EnhancedSegmentRenderer extends SegmentRenderer {
    async renderSegment(segment) {
        // First render the basic segment
        const baseElement = super.renderSegment(segment);
        
        // Check if segment needs visual enhancement
        if (this.shouldEnhanceWithVisual(segment)) {
            // Request visual generation from backend
            const visual = await this.generateVisual(segment);
            
            // Render the visual
            if (visual) {
                const visualElement = await this.renderVisual(visual);
                baseElement.appendChild(visualElement);
            }
        }
        
        return baseElement;
    }
    
    shouldEnhanceWithVisual(segment) {
        // Determine if segment type benefits from visual enhancement
        const visualSegmentTypes = [
            'technical_introduction', 'architecture_design',
            'metric_deep_dive', 'historical_context',
            'code_walkthrough', 'paradigm_shift',
            'simulation'
        ];
        
        return visualSegmentTypes.includes(segment.segmentType);
    }
    
    async generateVisual(segment) {
        try {
            const response = await fetch('/api/generate-visual', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({segment})
            });
            
            const result = await response.json();
            
            if (result.success) {
                return result.specification;
            }
        } catch (error) {
            console.error('Failed to generate visual:', error);
        }
        
        return null;
    }
    
    async renderVisual(specification) {
        // Use the LLMVisualRenderer to render the specification
        const renderer = new LLMVisualRenderer();
        const container = document.createElement('div');
        container.className = 'llm-generated-visual';
        
        await renderer.renderVisual(specification, container);
        
        return container;
    }
}

// Replace default renderer with enhanced version
window.segmentRenderer = new EnhancedSegmentRenderer();
"""


# Example usage in Flask app
def integrate_llm_visuals(app):
    """
    Integrate LLM visual generation with Flask app
    """
    # Initialize the integration
    visual_integration = LLMVisualIntegration(app)
    
    # Add to app context
    app.visual_integration = visual_integration
    
    # Modify segment rendering endpoint
    original_get_segment = app.view_functions.get('get_segment')
    
    def enhanced_get_segment(segment_id):
        # Get original segment data
        segment = original_get_segment(segment_id)
        
        if segment and isinstance(segment, dict):
            # Enhance with visual
            segment = enhance_segment_with_visual(segment, visual_integration)
        
        return segment
    
    # Replace endpoint
    app.view_functions['get_segment'] = enhanced_get_segment
    
    return visual_integration