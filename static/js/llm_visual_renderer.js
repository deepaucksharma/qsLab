/**
 * LLM Visual Renderer - Renders visual specifications generated by LLMs
 * This system takes JSON specifications and creates rich, interactive visualizations
 */

class LLMVisualRenderer {
    constructor() {
        this.components = new Map();
        this.activeVisuals = new Map();
        this.initializeComponents();
    }

    initializeComponents() {
        // Register all available visual components
        this.components.set('animated-diagram', AnimatedDiagramComponent);
        this.components.set('metric-dashboard', MetricDashboardComponent);
        this.components.set('interactive-timeline', InteractiveTimelineComponent);
        this.components.set('code-playground', CodePlaygroundComponent);
        this.components.set('comparison-view', ComparisonViewComponent);
        this.components.set('simulation', SimulationComponent);
    }

    async renderVisual(specification, targetElement) {
        try {
            // Validate specification
            if (!this.validateSpecification(specification)) {
                throw new Error('Invalid visual specification');
            }

            // Get appropriate component
            const ComponentClass = this.components.get(specification.visualType);
            if (!ComponentClass) {
                throw new Error(`Unknown visual type: ${specification.visualType}`);
            }

            // Create and render component
            const component = new ComponentClass(specification);
            await component.render(targetElement);

            // Store reference for cleanup
            this.activeVisuals.set(specification.visualId, component);

            return component;
        } catch (error) {
            console.error('Failed to render visual:', error);
            return this.renderFallback(specification, targetElement);
        }
    }

    validateSpecification(spec) {
        return spec && spec.visualType && spec.visualId;
    }

    renderFallback(spec, targetElement) {
        const fallback = document.createElement('div');
        fallback.className = 'visual-fallback';
        fallback.innerHTML = `
            <div class="fallback-content">
                <h3>${spec.title || 'Visual Content'}</h3>
                <p>Enhanced visual rendering is not available.</p>
                <pre>${JSON.stringify(spec, null, 2)}</pre>
            </div>
        `;
        targetElement.appendChild(fallback);
    }

    cleanup(visualId) {
        const component = this.activeVisuals.get(visualId);
        if (component && component.cleanup) {
            component.cleanup();
            this.activeVisuals.delete(visualId);
        }
    }
}

// Base Visual Component Class
class BaseVisualComponent {
    constructor(specification) {
        this.spec = specification;
        this.container = null;
        this.animations = [];
        this.interactions = [];
    }

    async render(targetElement) {
        // Create container
        this.container = document.createElement('div');
        this.container.className = `visual-component ${this.spec.visualType}`;
        this.container.id = this.spec.visualId;

        // Add title if provided
        if (this.spec.title) {
            const title = document.createElement('h3');
            title.className = 'visual-title';
            title.textContent = this.spec.title;
            this.container.appendChild(title);
        }

        // Render specific visual content
        await this.renderContent();

        // Set up animations
        this.setupAnimations();

        // Set up interactions
        this.setupInteractions();

        // Append to target
        targetElement.appendChild(this.container);
    }

    async renderContent() {
        // Override in subclasses
        throw new Error('renderContent must be implemented by subclass');
    }

    setupAnimations() {
        if (!this.spec.animations) return;

        this.spec.animations.forEach(animation => {
            if (animation.trigger === 'onLoad') {
                this.playAnimationSequence(animation.sequence);
            } else if (animation.trigger === 'onScroll') {
                this.setupScrollTrigger(animation);
            }
        });
    }

    setupInteractions() {
        if (!this.spec.interactions) return;

        this.spec.interactions.forEach(interaction => {
            const target = this.container.querySelector(`#${interaction.target}`);
            if (!target) return;

            switch (interaction.type) {
                case 'hover':
                    this.setupHoverInteraction(target, interaction);
                    break;
                case 'click':
                    this.setupClickInteraction(target, interaction);
                    break;
                case 'drag':
                    this.setupDragInteraction(target, interaction);
                    break;
            }
        });
    }

    cleanup() {
        // Clean up animations and event listeners
        this.animations.forEach(anim => anim.kill());
        this.interactions.forEach(handler => handler.remove());
    }
}

// Animated Diagram Component
class AnimatedDiagramComponent extends BaseVisualComponent {
    async renderContent() {
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('viewBox', '0 0 1000 600');
        svg.className = 'animated-diagram-svg';

        // Render components from specification
        if (this.spec.components) {
            this.spec.components.forEach(comp => {
                const element = this.createSVGElement(comp);
                svg.appendChild(element);
            });
        }

        this.container.appendChild(svg);
        this.svg = svg;
    }

    createSVGElement(component) {
        const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        group.id = component.id;
        group.setAttribute('transform', `translate(${component.position.x}, ${component.position.y})`);

        switch (component.type) {
            case 'topic':
                return this.createTopicElement(component, group);
            case 'partition':
                return this.createPartitionElement(component, group);
            case 'producer':
                return this.createProducerElement(component, group);
            case 'consumer':
                return this.createConsumerElement(component, group);
            default:
                return group;
        }
    }

    createTopicElement(component, group) {
        // Topic rectangle
        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('width', '200');
        rect.setAttribute('height', '100');
        rect.setAttribute('rx', '10');
        rect.className = 'topic-rect';
        group.appendChild(rect);

        // Topic label
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', '100');
        text.setAttribute('y', '50');
        text.setAttribute('text-anchor', 'middle');
        text.className = 'topic-label';
        text.textContent = component.label;
        group.appendChild(text);

        // Add partitions if specified
        if (component.properties && component.properties.partitionCount) {
            this.addPartitions(group, component.properties.partitionCount);
        }

        return group;
    }

    addPartitions(parentGroup, count) {
        const partitionGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        partitionGroup.className = 'partitions';

        for (let i = 0; i < count; i++) {
            const partition = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            partition.setAttribute('x', i * 70);
            partition.setAttribute('y', '120');
            partition.setAttribute('width', '60');
            partition.setAttribute('height', '40');
            partition.setAttribute('rx', '5');
            partition.className = 'partition';
            partition.setAttribute('data-partition', i);
            partitionGroup.appendChild(partition);

            // Partition label
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', i * 70 + 30);
            label.setAttribute('y', '145');
            label.setAttribute('text-anchor', 'middle');
            label.className = 'partition-label';
            label.textContent = `P${i}`;
            partitionGroup.appendChild(label);
        }

        parentGroup.appendChild(partitionGroup);
    }

    playAnimationSequence(sequence) {
        let delay = 0;

        sequence.forEach(step => {
            setTimeout(() => {
                this.executeAnimationStep(step);
            }, delay);
            delay += step.duration || 1000;
        });
    }

    executeAnimationStep(step) {
        switch (step.action) {
            case 'showComponent':
                this.animateShow(step.target, step.duration);
                break;
            case 'animateMessages':
                this.animateMessageFlow(step.from, step.to, step.count, step.duration);
                break;
            case 'highlight':
                this.animateHighlight(step.target, step.duration);
                break;
        }
    }

    animateMessageFlow(fromId, toId, count, duration) {
        const from = this.svg.querySelector(`#${fromId}`);
        const to = this.svg.querySelector(`#${toId}`);
        if (!from || !to) return;

        const fromRect = from.getBoundingClientRect();
        const toRect = to.getBoundingClientRect();
        const svgRect = this.svg.getBoundingClientRect();

        // Calculate positions relative to SVG
        const startX = (fromRect.left - svgRect.left) + fromRect.width;
        const startY = (fromRect.top - svgRect.top) + fromRect.height / 2;
        const endX = (toRect.left - svgRect.left);
        const endY = (toRect.top - svgRect.top) + toRect.height / 2;

        // Create and animate messages
        for (let i = 0; i < count; i++) {
            setTimeout(() => {
                const message = this.createMessage(startX, startY);
                this.animateMessage(message, endX, endY, duration / count);
            }, (duration / count) * i);
        }
    }

    createMessage(x, y) {
        const message = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        message.setAttribute('cx', x);
        message.setAttribute('cy', y);
        message.setAttribute('r', '8');
        message.className = 'animated-message';
        this.svg.appendChild(message);
        return message;
    }

    animateMessage(message, endX, endY, duration) {
        const animation = message.animate([
            { transform: `translate(0, 0)`, opacity: 1 },
            { transform: `translate(${endX - message.cx.baseVal.value}px, ${endY - message.cy.baseVal.value}px)`, opacity: 1 },
            { transform: `translate(${endX - message.cx.baseVal.value}px, ${endY - message.cy.baseVal.value}px)`, opacity: 0 }
        ], {
            duration: duration,
            easing: 'ease-in-out'
        });

        animation.onfinish = () => message.remove();
    }
}

// Metric Dashboard Component
class MetricDashboardComponent extends BaseVisualComponent {
    constructor(spec) {
        super(spec);
        this.charts = new Map();
        this.dataGenerators = new Map();
    }

    async renderContent() {
        const dashboard = document.createElement('div');
        dashboard.className = 'metric-dashboard-grid';

        // Apply layout
        if (this.spec.layout === 'grid' && this.spec.widgets) {
            dashboard.style.display = 'grid';
            dashboard.style.gridTemplateColumns = 'repeat(auto-fit, minmax(300px, 1fr))';
            dashboard.style.gap = '20px';

            // Render each widget
            this.spec.widgets.forEach((widget, index) => {
                const widgetEl = this.createWidget(widget, index);
                dashboard.appendChild(widgetEl);
            });
        }

        this.container.appendChild(dashboard);

        // Start data generation if specified
        if (this.spec.refreshRate && this.spec.dataSource === 'simulated') {
            this.startDataSimulation();
        }
    }

    createWidget(widgetSpec, index) {
        const widget = document.createElement('div');
        widget.className = `metric-widget ${widgetSpec.type}`;
        widget.id = `widget-${index}`;

        // Widget header
        const header = document.createElement('div');
        header.className = 'widget-header';
        header.innerHTML = `
            <h4>${widgetSpec.metric.replace(/_/g, ' ').toUpperCase()}</h4>
            ${widgetSpec.aggregation ? `<span class="aggregation">${widgetSpec.aggregation}</span>` : ''}
        `;
        widget.appendChild(header);

        // Widget content based on type
        const content = document.createElement('div');
        content.className = 'widget-content';

        switch (widgetSpec.type) {
            case 'time-series':
                content.appendChild(this.createTimeSeries(widgetSpec, index));
                break;
            case 'gauge':
                content.appendChild(this.createGauge(widgetSpec, index));
                break;
            case 'stat-card':
                content.appendChild(this.createStatCard(widgetSpec, index));
                break;
        }

        widget.appendChild(content);
        return widget;
    }

    createTimeSeries(spec, index) {
        const canvas = document.createElement('canvas');
        canvas.id = `chart-${index}`;
        canvas.width = 400;
        canvas.height = 200;

        // Initialize with empty chart
        const ctx = canvas.getContext('2d');
        const chart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: spec.metric,
                    data: [],
                    borderColor: 'rgb(75, 192, 192)',
                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true
                    }
                },
                plugins: {
                    annotation: {
                        annotations: this.createThresholdAnnotations(spec.thresholds)
                    }
                }
            }
        });

        this.charts.set(index, chart);
        return canvas;
    }

    createThresholdAnnotations(thresholds) {
        if (!thresholds) return {};

        const annotations = {};
        
        if (thresholds.warning) {
            annotations.warningLine = {
                type: 'line',
                yMin: thresholds.warning,
                yMax: thresholds.warning,
                borderColor: 'orange',
                borderWidth: 2,
                borderDash: [5, 5]
            };
        }

        if (thresholds.critical) {
            annotations.criticalLine = {
                type: 'line',
                yMin: thresholds.critical,
                yMax: thresholds.critical,
                borderColor: 'red',
                borderWidth: 2,
                borderDash: [5, 5]
            };
        }

        return annotations;
    }

    createGauge(spec, index) {
        const gaugeContainer = document.createElement('div');
        gaugeContainer.className = 'gauge-container';
        gaugeContainer.innerHTML = `
            <div class="gauge" id="gauge-${index}">
                <div class="gauge-meter">
                    <div class="gauge-fill" style="transform: rotate(0deg)"></div>
                </div>
                <div class="gauge-value">0</div>
                <div class="gauge-label">${spec.metric}</div>
            </div>
            ${spec.sparkline ? '<canvas class="sparkline" width="200" height="40"></canvas>' : ''}
        `;
        return gaugeContainer;
    }

    createStatCard(spec, index) {
        const card = document.createElement('div');
        card.className = 'stat-card';
        card.innerHTML = `
            <div class="stat-value" id="stat-${index}">--</div>
            <div class="stat-label">${spec.metric}</div>
            ${spec.showTrend ? '<div class="stat-trend">↑ 0%</div>' : ''}
        `;
        return card;
    }

    startDataSimulation() {
        // Generate data based on simulation profile
        const profile = this.spec.simulationProfile || 'normal';
        
        setInterval(() => {
            this.spec.widgets.forEach((widget, index) => {
                const value = this.generateDataPoint(widget.metric, profile);
                this.updateWidget(index, widget, value);
            });
        }, this.spec.refreshRate);
    }

    generateDataPoint(metric, profile) {
        const baseValues = {
            'unacknowledged_age_ms': 15000,
            'redelivery_count': 5,
            'message_count': 1000,
            'throughput': 500
        };

        const base = baseValues[metric] || 100;
        
        switch (profile) {
            case 'normal':
                return base + (Math.random() - 0.5) * base * 0.2;
            case 'normal-with-spikes':
                const spike = Math.random() > 0.95 ? 3 : 1;
                return base * spike + (Math.random() - 0.5) * base * 0.2;
            case 'increasing':
                return base * (1 + Date.now() / 100000000);
            default:
                return base;
        }
    }

    updateWidget(index, widget, value) {
        switch (widget.type) {
            case 'time-series':
                this.updateTimeSeries(index, value);
                break;
            case 'gauge':
                this.updateGauge(index, value);
                break;
            case 'stat-card':
                this.updateStatCard(index, value);
                break;
        }
    }

    updateTimeSeries(index, value) {
        const chart = this.charts.get(index);
        if (!chart) return;

        const now = new Date().toLocaleTimeString();
        chart.data.labels.push(now);
        chart.data.datasets[0].data.push(value);

        // Keep only last 20 points
        if (chart.data.labels.length > 20) {
            chart.data.labels.shift();
            chart.data.datasets[0].data.shift();
        }

        chart.update('none'); // No animation for real-time updates
    }

    cleanup() {
        super.cleanup();
        // Clean up charts
        this.charts.forEach(chart => chart.destroy());
        // Stop data generators
        this.dataGenerators.forEach(generator => clearInterval(generator));
    }
}

// Code Playground Component
class CodePlaygroundComponent extends BaseVisualComponent {
    async renderContent() {
        const playground = document.createElement('div');
        playground.className = 'code-playground';

        // Create editor section
        const editorSection = document.createElement('div');
        editorSection.className = 'editor-section';
        
        const editorContainer = document.createElement('div');
        editorContainer.className = 'code-editor';
        editorContainer.id = 'editor-' + this.spec.visualId;
        editorSection.appendChild(editorContainer);

        // Create visualization section
        const vizSection = document.createElement('div');
        vizSection.className = 'visualization-section';

        if (this.spec.visualizations) {
            this.spec.visualizations.forEach(viz => {
                if (viz.type === 'execution-flow') {
                    vizSection.appendChild(this.createExecutionFlow(viz));
                }
            });
        }

        // Create output section
        const outputSection = document.createElement('div');
        outputSection.className = 'output-section';
        outputSection.innerHTML = `
            <div class="output-header">
                <h5>Output</h5>
                <button class="run-button">▶ Run</button>
            </div>
            <div class="output-content">
                <pre class="output-text"></pre>
            </div>
        `;

        playground.appendChild(editorSection);
        playground.appendChild(vizSection);
        playground.appendChild(outputSection);

        this.container.appendChild(playground);

        // Initialize code editor
        this.initializeEditor(editorContainer);

        // Set up run button
        const runButton = outputSection.querySelector('.run-button');
        runButton.addEventListener('click', () => this.executeCode());
    }

    initializeEditor(container) {
        // Initialize CodeMirror or Monaco editor
        this.editor = CodeMirror(container, {
            value: this.spec.code || '',
            mode: this.getEditorMode(this.spec.language),
            theme: 'monokai',
            lineNumbers: true,
            autoCloseBrackets: true,
            matchBrackets: true,
            indentUnit: 2,
            tabSize: 2
        });

        // Add interactive elements
        if (this.spec.interactiveElements) {
            this.spec.interactiveElements.forEach(element => {
                this.addInteractiveElement(element);
            });
        }
    }

    getEditorMode(language) {
        const modeMap = {
            'java': 'text/x-java',
            'javascript': 'javascript',
            'python': 'python',
            'go': 'go'
        };
        return modeMap[language] || 'text/plain';
    }

    createExecutionFlow(viz) {
        const flow = document.createElement('div');
        flow.className = 'execution-flow';
        flow.innerHTML = `
            <h5>Execution Flow</h5>
            <div class="flow-diagram">
                <canvas id="flow-canvas" width="400" height="300"></canvas>
            </div>
            ${viz.showMemoryState ? '<div class="memory-state"></div>' : ''}
        `;
        return flow;
    }

    executeCode() {
        const code = this.editor.getValue();
        const output = this.container.querySelector('.output-text');

        // Simulate code execution
        output.textContent = 'Executing...\n';

        // For demo purposes, simulate execution based on language
        setTimeout(() => {
            if (this.spec.executionMode === 'step-through') {
                this.executeStepThrough(code, output);
            } else {
                this.executeNormal(code, output);
            }
        }, 500);
    }

    executeStepThrough(code, output) {
        const lines = code.split('\n');
        let currentLine = 0;

        const stepInterval = setInterval(() => {
            if (currentLine < lines.length) {
                // Highlight current line
                this.editor.addLineClass(currentLine, 'wrap', 'executing-line');
                
                // Remove highlight from previous line
                if (currentLine > 0) {
                    this.editor.removeLineClass(currentLine - 1, 'wrap', 'executing-line');
                }

                // Show execution state
                output.textContent += `Line ${currentLine + 1}: ${lines[currentLine]}\n`;

                currentLine++;
            } else {
                clearInterval(stepInterval);
                output.textContent += '\nExecution completed!';
            }
        }, 1000);
    }

    executeNormal(code, output) {
        // Simulate normal execution
        output.textContent = `Executing ${this.spec.language} code...\n\n`;
        
        // Mock output based on code content
        if (code.includes('poll')) {
            output.textContent += 'Polling for messages...\n';
            output.textContent += 'Received 5 messages from partition 0\n';
            output.textContent += 'Processing records...\n';
            output.textContent += 'Acknowledging messages\n';
            output.textContent += 'Poll cycle completed\n';
        } else {
            output.textContent += 'Code executed successfully!';
        }
    }

    addInteractiveElement(element) {
        // Add parameter adjusters or other interactive elements
        const line = element.line - 1; // CodeMirror is 0-indexed
        
        if (element.type === 'parameter-adjuster') {
            const widget = document.createElement('input');
            widget.type = 'range';
            widget.min = element.range[0];
            widget.max = element.range[1];
            widget.value = (element.range[0] + element.range[1]) / 2;
            widget.className = 'parameter-adjuster';
            
            widget.addEventListener('input', (e) => {
                // Update the code
                const currentLine = this.editor.getLine(line);
                const newLine = currentLine.replace(/\d+/, e.target.value);
                this.editor.replaceRange(newLine, 
                    {line: line, ch: 0}, 
                    {line: line, ch: currentLine.length}
                );
            });

            this.editor.addWidget({line: line, ch: 0}, widget, false);
        }
    }
}

// Comparison View Component
class ComparisonViewComponent extends BaseVisualComponent {
    async renderContent() {
        const comparison = document.createElement('div');
        comparison.className = `comparison-view ${this.spec.layout}`;

        if (this.spec.subjects && this.spec.subjects.length >= 2) {
            // Create subject panels
            this.spec.subjects.forEach((subject, index) => {
                const panel = this.createSubjectPanel(subject, index);
                comparison.appendChild(panel);
            });

            // Add comparison controls
            if (this.spec.interactiveToggle) {
                const controls = this.createComparisonControls();
                comparison.appendChild(controls);
            }
        }

        this.container.appendChild(comparison);

        // Set up transition effects
        if (this.spec.transitionEffect) {
            this.setupTransitionEffects();
        }
    }

    createSubjectPanel(subject, index) {
        const panel = document.createElement('div');
        panel.className = 'subject-panel';
        panel.id = `subject-${index}`;

        // Title
        const title = document.createElement('h4');
        title.className = 'subject-title';
        title.textContent = subject.title;
        panel.appendChild(title);

        // Visualization
        if (subject.visualization) {
            const vizContainer = document.createElement('div');
            vizContainer.className = 'subject-visualization';
            this.renderSubjectVisualization(subject.visualization, vizContainer);
            panel.appendChild(vizContainer);
        }

        // Key points
        if (subject.keyPoints) {
            const points = document.createElement('ul');
            points.className = 'key-points';
            subject.keyPoints.forEach(point => {
                const li = document.createElement('li');
                li.textContent = point;
                points.appendChild(li);
            });
            panel.appendChild(points);
        }

        return panel;
    }

    renderSubjectVisualization(viz, container) {
        switch (viz.type) {
            case 'partition-assignment':
                this.renderPartitionAssignment(viz, container);
                break;
            case 'cooperative-consumption':
                this.renderCooperativeConsumption(viz, container);
                break;
        }
    }

    renderPartitionAssignment(viz, container) {
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('viewBox', '0 0 400 300');
        svg.className = 'partition-assignment-viz';

        // Draw partitions
        for (let i = 0; i < 3; i++) {
            const partition = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            partition.setAttribute('x', 50);
            partition.setAttribute('y', 50 + i * 70);
            partition.setAttribute('width', 100);
            partition.setAttribute('height', 50);
            partition.setAttribute('rx', 5);
            partition.className = 'partition';
            svg.appendChild(partition);

            // Draw consumer
            const consumer = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            consumer.setAttribute('cx', 250);
            consumer.setAttribute('cy', 75 + i * 70);
            consumer.setAttribute('r', 20);
            consumer.className = 'consumer';
            svg.appendChild(consumer);

            // Draw connection
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', 150);
            line.setAttribute('y1', 75 + i * 70);
            line.setAttribute('x2', 230);
            line.setAttribute('y2', 75 + i * 70);
            line.className = 'connection';
            svg.appendChild(line);
        }

        if (viz.showLimitations) {
            // Add "no more consumers" indicator
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', 200);
            text.setAttribute('y', 280);
            text.setAttribute('text-anchor', 'middle');
            text.className = 'limitation-text';
            text.textContent = '⚠️ Max consumers reached';
            svg.appendChild(text);
        }

        container.appendChild(svg);
    }

    renderCooperativeConsumption(viz, container) {
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('viewBox', '0 0 400 300');
        svg.className = 'cooperative-consumption-viz';

        // Draw single partition
        const partition = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        partition.setAttribute('x', 50);
        partition.setAttribute('y', 100);
        partition.setAttribute('width', 100);
        partition.setAttribute('height', 100);
        partition.setAttribute('rx', 5);
        partition.className = 'partition large';
        svg.appendChild(partition);

        // Draw multiple consumers
        for (let i = 0; i < 4; i++) {
            const consumer = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            consumer.setAttribute('cx', 250 + (i % 2) * 50);
            consumer.setAttribute('cy', 100 + Math.floor(i / 2) * 50);
            consumer.setAttribute('r', 20);
            consumer.className = 'consumer cooperative';
            svg.appendChild(consumer);

            // Draw connections
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', 150);
            line.setAttribute('y1', 150);
            line.setAttribute('x2', 230 + (i % 2) * 50);
            line.setAttribute('y2', 100 + Math.floor(i / 2) * 50);
            line.className = 'connection cooperative';
            svg.appendChild(line);
        }

        if (viz.showAdvantages) {
            // Add advantage indicator
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', 200);
            text.setAttribute('y', 280);
            text.setAttribute('text-anchor', 'middle');
            text.className = 'advantage-text';
            text.textContent = '✓ Flexible scaling';
            svg.appendChild(text);
        }

        container.appendChild(svg);
    }

    createComparisonControls() {
        const controls = document.createElement('div');
        controls.className = 'comparison-controls';
        controls.innerHTML = `
            <button class="compare-toggle">Toggle Comparison</button>
            <button class="morph-transition">Show Transformation</button>
        `;

        const toggleBtn = controls.querySelector('.compare-toggle');
        toggleBtn.addEventListener('click', () => this.toggleComparison());

        const morphBtn = controls.querySelector('.morph-transition');
        morphBtn.addEventListener('click', () => this.morphTransition());

        return controls;
    }

    toggleComparison() {
        const panels = this.container.querySelectorAll('.subject-panel');
        panels.forEach(panel => {
            panel.classList.toggle('highlighted');
        });
    }

    morphTransition() {
        if (this.spec.transitionEffect === 'morph') {
            // Implement morphing animation between the two visualizations
            const panel1 = this.container.querySelector('#subject-0');
            const panel2 = this.container.querySelector('#subject-1');

            panel1.classList.add('morphing');
            panel2.classList.add('morphing');

            setTimeout(() => {
                panel1.classList.remove('morphing');
                panel2.classList.remove('morphing');
            }, 2000);
        }
    }
}

// Simulation Component
class SimulationComponent extends BaseVisualComponent {
    constructor(spec) {
        super(spec);
        this.simulationState = {
            running: false,
            consumers: 1,
            productionRate: 100,
            queueDepth: 0,
            processingLag: 0
        };
    }

    async renderContent() {
        const simulation = document.createElement('div');
        simulation.className = 'simulation-container';

        // Create control panel
        const controls = this.createControlPanel();
        simulation.appendChild(controls);

        // Create visualization area
        const vizArea = document.createElement('div');
        vizArea.className = 'simulation-viz';
        vizArea.innerHTML = `
            <canvas id="sim-canvas" width="800" height="400"></canvas>
        `;
        simulation.appendChild(vizArea);

        // Create metrics panel
        const metrics = this.createMetricsPanel();
        simulation.appendChild(metrics);

        this.container.appendChild(simulation);

        // Initialize simulation
        this.initializeSimulation(vizArea.querySelector('#sim-canvas'));
    }

    createControlPanel() {
        const panel = document.createElement('div');
        panel.className = 'control-panel';
        panel.innerHTML = `
            <div class="control-group">
                <label>Consumers: <span id="consumer-count">1</span></label>
                <input type="range" id="consumer-slider" min="1" max="10" value="1">
            </div>
            <div class="control-group">
                <label>Production Rate: <span id="production-rate">100</span> msg/s</label>
                <input type="range" id="production-slider" min="50" max="500" value="100" step="10">
            </div>
            <div class="control-group">
                <button id="start-sim" class="sim-button">Start Simulation</button>
                <button id="reset-sim" class="sim-button">Reset</button>
            </div>
        `;

        // Set up event listeners
        const consumerSlider = panel.querySelector('#consumer-slider');
        consumerSlider.addEventListener('input', (e) => {
            this.simulationState.consumers = parseInt(e.target.value);
            panel.querySelector('#consumer-count').textContent = e.target.value;
            this.updateSimulation();
        });

        const productionSlider = panel.querySelector('#production-slider');
        productionSlider.addEventListener('input', (e) => {
            this.simulationState.productionRate = parseInt(e.target.value);
            panel.querySelector('#production-rate').textContent = e.target.value;
        });

        const startBtn = panel.querySelector('#start-sim');
        startBtn.addEventListener('click', () => this.toggleSimulation());

        const resetBtn = panel.querySelector('#reset-sim');
        resetBtn.addEventListener('click', () => this.resetSimulation());

        return panel;
    }

    createMetricsPanel() {
        const panel = document.createElement('div');
        panel.className = 'metrics-panel';
        panel.innerHTML = `
            <div class="metric">
                <div class="metric-label">Queue Depth</div>
                <div class="metric-value" id="queue-depth">0</div>
            </div>
            <div class="metric">
                <div class="metric-label">Processing Lag</div>
                <div class="metric-value" id="processing-lag">0 ms</div>
            </div>
            <div class="metric">
                <div class="metric-label">Throughput</div>
                <div class="metric-value" id="throughput">0 msg/s</div>
            </div>
            <div class="metric">
                <div class="metric-label">Score</div>
                <div class="metric-value" id="score">0</div>
            </div>
        `;
        return panel;
    }

    initializeSimulation(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.messages = [];
        this.consumerPositions = [];

        // Draw initial state
        this.drawSimulation();
    }

    toggleSimulation() {
        this.simulationState.running = !this.simulationState.running;
        const btn = this.container.querySelector('#start-sim');
        btn.textContent = this.simulationState.running ? 'Stop Simulation' : 'Start Simulation';

        if (this.simulationState.running) {
            this.runSimulation();
        }
    }

    runSimulation() {
        if (!this.simulationState.running) return;

        // Generate new messages based on production rate
        if (Math.random() < this.simulationState.productionRate / 100) {
            this.messages.push({
                x: 50,
                y: 200 + (Math.random() - 0.5) * 50,
                processed: false,
                age: 0
            });
        }

        // Process messages with consumers
        const processingCapacity = this.simulationState.consumers * 20; // msgs per consumer
        let processed = 0;

        this.messages = this.messages.filter(msg => {
            if (!msg.processed && processed < processingCapacity) {
                msg.processed = true;
                processed++;
            }
            
            if (msg.processed) {
                msg.x += 5; // Move processed messages
                return msg.x < 800; // Keep if still visible
            } else {
                msg.age++;
                return true;
            }
        });

        // Update metrics
        this.updateMetrics();

        // Draw frame
        this.drawSimulation();

        // Continue simulation
        requestAnimationFrame(() => this.runSimulation());
    }

    updateMetrics() {
        const unprocessed = this.messages.filter(m => !m.processed);
        this.simulationState.queueDepth = unprocessed.length;
        
        const maxAge = unprocessed.reduce((max, msg) => Math.max(max, msg.age), 0);
        this.simulationState.processingLag = maxAge * 10; // Convert to ms

        // Update display
        this.container.querySelector('#queue-depth').textContent = this.simulationState.queueDepth;
        this.container.querySelector('#processing-lag').textContent = this.simulationState.processingLag + ' ms';
        this.container.querySelector('#throughput').textContent = 
            Math.round(this.simulationState.consumers * 20) + ' msg/s';

        // Calculate score based on efficiency
        const efficiency = 1 - (this.simulationState.queueDepth / 100);
        const score = Math.max(0, Math.round(efficiency * 1000));
        this.container.querySelector('#score').textContent = score;
    }

    drawSimulation() {
        // Clear canvas
        this.ctx.clearRect(0, 0, 800, 400);

        // Draw queue
        this.ctx.fillStyle = '#333';
        this.ctx.fillRect(50, 150, 200, 100);
        this.ctx.fillStyle = '#fff';
        this.ctx.font = '16px sans-serif';
        this.ctx.fillText('Message Queue', 100, 135);

        // Draw messages
        this.messages.forEach(msg => {
            this.ctx.fillStyle = msg.processed ? '#4CAF50' : '#FF5722';
            this.ctx.beginPath();
            this.ctx.arc(msg.x, msg.y, 5, 0, Math.PI * 2);
            this.ctx.fill();
        });

        // Draw consumers
        for (let i = 0; i < this.simulationState.consumers; i++) {
            const y = 200 - (this.simulationState.consumers - 1) * 15 + i * 30;
            this.ctx.fillStyle = '#2196F3';
            this.ctx.fillRect(300, y - 15, 60, 30);
            this.ctx.fillStyle = '#fff';
            this.ctx.fillText(`C${i + 1}`, 320, y + 5);
        }

        // Draw processing area
        this.ctx.strokeStyle = '#666';
        this.ctx.strokeRect(400, 100, 350, 200);
        this.ctx.fillStyle = '#666';
        this.ctx.fillText('Processing', 550, 90);
    }

    resetSimulation() {
        this.simulationState.running = false;
        this.simulationState.queueDepth = 0;
        this.simulationState.processingLag = 0;
        this.messages = [];
        
        const btn = this.container.querySelector('#start-sim');
        btn.textContent = 'Start Simulation';

        this.drawSimulation();
        this.updateMetrics();
    }

    updateSimulation() {
        // Redraw with new consumer count
        if (!this.simulationState.running) {
            this.drawSimulation();
        }
    }
}

// Export the renderer
window.LLMVisualRenderer = LLMVisualRenderer;